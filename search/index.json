{"authors":[],"categories":["Tutorial","Three.js"],"pages":[{"authors":[],"authors_titles":"","categories":[{"title":"Tutorial","url":"https://pnichols04.github.io/categories/tutorial/"},{"title":"Three.js","url":"https://pnichols04.github.io/categories/three.js/"}],"categories_titles":"Tutorial Three.js","content":"In this series of posts, we\u0026rsquo;ll explore how to implement a boids-type flocking simulation in Three.js.\nBackground# Boids (“bird-oid objects”) are the basis of an artificial life program that mimics the flocking behavior of birds or the schooling of fish. The concept was initially developed in 1986 by Craig Reynolds, a member of the visual effects teams on 1982\u0026rsquo;s Tron and 1992\u0026rsquo;s Batman Returns, among a number of other feature films.\nIn the simplest boids program, like the one we’ll develop initially, the boids demonstrate three behaviors:\nSeparation Boids will steer to avoid crowding their nearby flockmates. Alignment Boids will steer toward the average heading of their nearby flockmates. Cohesion Boids will steer toward the average location (“center of mass”) of their nearby flockmates. Bootstrapping the Project# We’ll begin with a fairly basic Three.js setup.\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3 \u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Boids in Three.js\u0026lt;/title\u0026gt; 5 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; 6 \u0026lt;script 7 async 8 src=\u0026#34;https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js\u0026#34; 9 \u0026gt;\u0026lt;/script\u0026gt; 10 \u0026lt;script type=\u0026#34;importmap\u0026#34;\u0026gt; 11 { 12 \u0026#34;imports\u0026#34;: { 13 \u0026#34;three\u0026#34;: \u0026#34;https://unpkg.com/three@0.143.0/build/three.module.js\u0026#34; 14 } 15 } 16 \u0026lt;/script\u0026gt; 17 \u0026lt;style\u0026gt; 18 body { 19 margin: 0; 20 height: 100%; 21 } 22 #c { 23 width: 100%; 24 height: 100%; 25 display: block; 26 } 27 \u0026lt;/style\u0026gt; 28 \u0026lt;/head\u0026gt; 29 30 \u0026lt;body\u0026gt; 31 \u0026lt;canvas id=\u0026#34;c\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; 32 \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 33 \u0026lt;/body\u0026gt; 34\u0026lt;/html\u0026gt; 1import * as THREE from \u0026#34;three\u0026#34;; 2 3const [ renderer, scene, camera ] = init(); 4 5 6// Code specific to the boids example will be placed here. 7 8 9animate(); 10 11 12function animate() { 13 14 requestAnimationFrame( animate ); 15 16 if ( resizeRendererToDisplaySize( renderer ) ) { 17 18 const canvas = renderer.domElement; 19 camera.aspect = canvas.clientWidth / canvas.clientHeight; 20 camera.updateProjectionMatrix(); 21 22 } 23 24 renderer.render( scene, camera ); 25 26} 27 28 29function init() { 30 31 const scene = new THREE.Scene(); 32 const camera = new THREE.PerspectiveCamera( 33 75, 34 window.innerWidth / window.innerHeight, 35 0.1, 36 500 37 ); 38 camera.position.set( 0, 5, 5 ); 39 camera.lookAt( 0, 0, 0 ); 40 41 const dirLight = new THREE.DirectionalLight( 0xffffff, 1. ); 42 dirLight.position.set( - 1, 2, 4 ); 43 scene.add( dirLight ); 44 45 const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 ); 46 hemiLight.color.setHSL( 0.6, 1, 0.6 ); 47 hemiLight.groundColor.setHSL( 0.095, 1, 0.75 ); 48 hemiLight.position.set( 0, 50, 0 ); 49 scene.add( hemiLight ); 50 51 const canvas = document.getElementById( \u0026#39;c\u0026#39; ); 52 const renderer = new THREE.WebGLRenderer( { 53 canvas, 54 antialias: true, 55 } ); 56 return [ renderer, scene, camera ]; 57 58} 59 60 61function resizeRendererToDisplaySize( renderer ) { 62 63 const canvas = renderer.domElement; 64 const pixelRatio = window.devicePixelRatio; 65 const width = canvas.clientWidth * pixelRatio | 0; 66 const height = canvas.clientHeight * pixelRatio | 0; 67 const needResize = canvas.width !== width || canvas.height !== height; 68 if ( needResize ) { 69 70 renderer.setSize( width, height, false ); 71 72 } 73 74 return needResize; 75 76} That’s a lot of code to render nothing at all, but it\u0026rsquo;s all similar to where most Three.js examples start. As usual, we set up a scene, camera, and renderer, as well as some lights. We put that logic into an init() function so that we can move it to the back end of the code file, where it will be out of the way of our more interesting work here.\nBack to Basics If you need help setting up a Three.js scene like this, a number of tutorials are available. Each of the following sites provides a solid introduction to the fundamentals, as well as coverage of more advanced and compelling techniques.\nThree.js docs Lewy Blue’s Discover Three.js! Sean Bradley’s Three.js and TypeScript Tutorials Creating the First Boid# BufferGeometry Objects This section assumes some familiarity with Three.js BufferGeometry objects.\nWe’ll keep the geometry of our boids simple; they’ll just be small square pyramids. For that, we’ll declare a function to create a buffer geometry for the pyramid, which we’ll be able to re-use for all of the boids.\nThe pyramid comprises five points: the apex (A) and four points for the base (B–E). It also comprises six faces: one for each of the triangular angled sides, and one for the base. Because the base is a quadrilateral, we’ll need two triangles to represent it.\nPyramid geometry for the boids\rThat’s not enough geometry for good smooth-shading support, however, so we’ll repeat the vertices as needed, so that we end up with flat shading.\nFor pleasant proportions, we\u0026rsquo;ll construct the pyramids so that the height will be in the\ngolden ratio to the diagonal of the base. After the import statements in the script, we\u0026rsquo;ll add a constant, PHI, to represent that ratio.\n1const PHI = ( 1. + Math.sqrt( 5. ) ) / 2.; Now we can declare a function to consruct a BufferGeometry that describes the pyramid. For our current purposes, we only need to construct a position array; repeating the vertices, which we’re doing to support flat shading, also relieves us from worrying about index, color, normal, and uv, at least for now.\n1function createBoidGeometry() { 2 3 const r = ( PHI - 1. ) / 4. * PHI; 4 const h = 1. / PHI; 5 6 const position = Float32Array.from( [ 7 // Angled side in +x, -z 8 0, h, 0, // A (apex) 9 r, 0, 0, // B (base corner in +x) 10 0, 0, - 1. * r, // C (base corner in -z) 11 12 // Angled side in -x, -z 13 0, h, 0, // A 14 0, 0, - 1. * r, // C 15 - 1. * r, 0, 0, // D (base corner in -x) 16 17 // Angled side in -x, +z 18 0, h, 0, // A 19 - 1. * r, 0, 0, // D 20 0, 0, r, // E (base corner in -x) 21 22 // Angled side in +x, +z 23 0, h, 0, // A 24 0, 0, r, // E 25 r, 0, 0, // B 26 27 // Base half in -z 28 0, 0, - 1. * r, // C 29 r, 0, 0, // B 30 - 1. * r, 0, 0, // D 31 32 // Base half in +z 33 r, 0, 0, // B 34 0, 0, r, // E 35 - 1. * r, 0, 0, // D 36 ] ); 37 38 const geometry = new THREE.BufferGeometry(); 39 geometry.setAttribute( 40 \u0026#39;position\u0026#39;, 41 new THREE.Float32BufferAttribute( position, 3 ) 42 ); 43 geometry.computeVertexNormals(); 44 45 return geometry; 46 47} We can use the geometry returned from the createBoidGeometry function together with a Material to construct a Mesh.\n1const boidMaterial = new THREE.MeshPhongMaterial( { 2 color: 0x049ef4, 3 emissive: 0x000000, 4 specular: 0x111111, 5 shininess: 30, 6 reflectivity: 1, 7 refractionRatio: 0.98, 8} ); 9 10const boidGeometry = createBoidGeometry(); 11 12// Prototype boid 13const boidMesh = new THREE.Mesh( boidGeometry, boidMaterial ); 14scene.add( boidMesh ); 15// End Now we can fire up a web server (see any of the introductory tutorials referred to above) and see our prototypical boid.\nRendered prototype boid\rMore Boids# One boid doesn’t make for much of a demonstration of flocking behaviors. To fill out the flock, we\u0026rsquo;ll distribute several boids throughout the world. Our distribution method here will be to select random points in camera space and unproject them into world space. This choice of method is arbitrary, though; any method that created a bunch of boids distributed in space would suffice.\nOnce we start the boids flocking, we’ll need to address each one during each frame of the animation, so we’ll also create an array to hold references to them. This way, we won’t have to walk the scene graph every frame for this purpose.\nFirst, we’ll add a params object before the call to the init() function to store the number of boids we want to create. (We’re using an object here, rather than a value, to support the GUI we’ll add at the end of this post. We define it before the call to init() so that we can construct that GUI inside of init() later.)\n1const params = { 2 boidsCount: 64, 3}; Now, let’s replace the code between “// Prototype boid” and “// End”, which created a single prototype boid with the following code to create our specified number of boids.\n1// Create a flock of boids 2function createBoids() { 3 4 while ( boids.length \u0026lt; params.boidsCount ) { 5 6 // Get random x, y, and z in camera space 7 const cameraSpaceLocation = new THREE.Vector3( 8 THREE.MathUtils.lerp( - 1., 1., Math.random() ), 9 THREE.MathUtils.lerp( - 1., 1., Math.random() ), 10 THREE.MathUtils.lerp( 0.94, 0.99, Math.random() ) 11 ); 12 // Unproject camera space location to world space 13 const worldLocation = cameraSpaceLocation.clone().unproject( camera ); 14 15 // Create and position mesh 16 const boidMesh = new THREE.Mesh( boidGeometry, boidMaterial ); 17 boidMesh.position.copy( worldLocation ); 18 19 boids.push( boidMesh ); 20 scene.add( boidMesh ); 21 22 } 23 24} 25 26createBoids(); 27// End And now we’re looking at something like this.\nMany boids\rWhy (How) Does This Work? While we usually think of the screen as a plane, screen space or camera space is a cube, with x, y, and z values in the closed interval [ −1.0, 1.0 ]. (These are called normalized device coordinates.) By choosing random values in those intervals and unprojecting them into world space, we yield points that are distributed throughout that portion of the world that lies within the camera\u0026rsquo;s view frustum.\nIn this sense, the x and y values, which range from left to right and top to bottom edges of the screen, respectively, are fairly intuitive. The z value, which ranges from the camera\u0026rsquo;s near clipping plane to its far clipping plane, is less so. It will suffice for now to say that the z values in camera space unproject to world space in a fashion that is weighted extremely heavily toward the near clipping plane and thus toward the camera itself.\nTherefore, rather than selecting values over the whole interval of z (like we do for x and y), we select values at the high end of the interval (0.94 to 0.99 in the provided code). This avoids having the points cluster very near to the camera.\nNow we have lots of boids, and those boids are starting out distributed throughout our view of the world. With just a couple more foundational items, we’ll be ready to start making them flock.\nPerformance Counters and GUI# As a final step in the project’s initial setup, we’ll add performance counters and a GUI.\nPerformance Counters# First, we import the Stats module by adding this line after the import for Three.js itself.\n1import Stats from \u0026#39;https://unpkg.com/three@0.143.0/examples//jsm/libs/stats.module.js\u0026#39;; Then, before the return from the init() function, we’ll initialize the Stats object. Additionally, we’ll modify the return statement to also return the Stats object, so that we can hold a reference to it for updating the display.\n1- return [ renderer, scene, camera ]; 2+ const stats = new Stats(); 3+ document.body.appendChild( stats.dom ); 4 5+ return [ renderer, scene, camera, stats ]; Then we’ll modify the call to init() to capture that reference.\n1- const [ renderer, scene, camera ] = init(); 2+ const [ renderer, scene, camera, stats ] = init(); And, finally, we’ll update the Stats object inside of the animate() function, just before the call to renderer.render(…).\n1+ stats.update(); 2 3 renderer.render( scene, camera ); GUI# Many of the parameters that will appear in later articles in this series will be amenable to run-time tweaking. A GUI will offer substantial assistance in this regard.\nWe’ll start by importing the GUI module included with Three.js.\n1import { GUI } from \u0026#39;https://unpkg.com/three@0.143.0/examples/jsm/libs/lil-gui.module.min.js\u0026#39;; Now, we’ll construct the GUI inside of the init() function.\n1 const gui = new GUI(); 2 gui.add( params, \u0026#39;boidsCount\u0026#39;, 8, 1024, 1 ) 3 .name( \u0026#34;Number of boids\u0026#34; ) 4 .onChange( createBoids ); Right away, we can drag the slider right to add boids to the scene.\nTo be able to remove them, we’ll add another while loop to the createBoids() function.\n1 while ( boids.length \u0026gt; params.boidsCount ) { 2 3 const boidToRemove = boids.pop(); 4 scene.remove( boidToRemove ); 5 6 } Conclusion# The complete code for this post is embedded below. In the next post in this series, we’ll add the actual flocking behaviors to our boids.\n","date":"August 30, 2022","img":"https://pnichols04.github.io/images/many-boids.webp","lang":"en","langName":"English","largeImg":"","permalink":"https://pnichols04.github.io/blog/threejs-boids-0-setting-up/","series":[{"title":"Boids in Three.js","url":"https://pnichols04.github.io/series/boids-in-three.js/"}],"series_titles":"Boids in Three.js","smallImg":"","tags":[{"title":"Three.js","url":"https://pnichols04.github.io/tags/three.js/"},{"title":"Boids","url":"https://pnichols04.github.io/tags/boids/"}],"tags_titles":"Three.js Boids","timestamp":1661864400,"title":"Boids in Three.js, Part Zero: Setting Up"},{"authors":[],"authors_titles":"","categories":[],"categories_titles":"","content":"I’ve been programming for the web since before it was really considered “programming.” That means I’ve made my share of passé offenses against good aesthetics (I’m looking at you, iframe sidebars and procedural MIDI theme music). But it also means I’ve seen enough tech come and go to know what adds enough to the web as a development platform to have staying power. It also means I can build sites and apps on the cutting edge without creating tomorrow’s legacy support burden.\nI’ve worked in a number of industries, so I know that tech needs to serve business concerns, and not the other way around. With that comes the real-world business experience to make sure that it does.\nThis blog is a vehicle for exploring end-to-end solutions to interesting development challenges, which is a need ill-served by the bite-sized form factor of a lot of programming resources. What’s more, I think we as an industry disserve ourselves by leaving people entering the field to piece things together by themselves.\nI am always available for consulting work. My services include:\nWeb site development and deployment Outsource technology integrations (maps, real-time 2D and 3D graphics, data and charting, etc.) In-house application development, customization, integration, and deployment Code and performance reviews Training and tutoring ","date":"February 28, 2019","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://pnichols04.github.io/about/","series":[],"series_titles":"","smallImg":"","tags":[],"tags_titles":"","timestamp":1551312000,"title":"About"},{"authors":[],"authors_titles":"","categories":[],"categories_titles":"","content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://pnichols04.github.io/contact/","series":[],"series_titles":"","smallImg":"","tags":[],"tags_titles":"","timestamp":-62135596800,"title":"Contact Me"},{"authors":[],"authors_titles":"","categories":[],"categories_titles":"","content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://pnichols04.github.io/offline/","series":[],"series_titles":"","smallImg":"","tags":[],"tags_titles":"","timestamp":-62135596800,"title":"Offline"},{"authors":[],"authors_titles":"","categories":[],"categories_titles":"","content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"","largeImg":"","permalink":"https://pnichols04.github.io/zh-cn/offline/","series":[],"series_titles":"","smallImg":"","tags":[],"tags_titles":"","timestamp":-62135596800,"title":"Offline"},{"authors":[],"authors_titles":"","categories":[],"categories_titles":"","content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"","largeImg":"","permalink":"https://pnichols04.github.io/zh-cn/contact/","series":[],"series_titles":"","smallImg":"","tags":[],"tags_titles":"","timestamp":-62135596800,"title":"联系我们"}],"series":["Boids in Three.js"],"tags":["Three.js","Boids"]}